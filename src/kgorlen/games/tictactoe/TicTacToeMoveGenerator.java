package kgorlen.games.tictactoe;

import java.util.NoSuchElementException;

import kgorlen.games.Move;
import kgorlen.games.MoveGenerator;

/**
 * Generate legal Tic-Tac-Toe moves
 * 
 * @author Keith gorlen@comcast.net
 *
 */
public class TicTacToeMoveGenerator implements MoveGenerator {
	private static enum State {
		INITIAL, KILLER, THREATEN_159, THREATEN_357,
		THREATEN_ROW,  THREATEN_COL, CENTER, CORNERS, SIDES
	};
	
// Move type statistics
	private static long[] MoveCount = new long[State.values().length];
	
	public static void resetStatistics() {
		for (State i : State.values()) {
			MoveCount[i.ordinal()] = 0;
		}
	}

	public static void printStatistics() {
		System.out.print("Move types:");
		for (State i : State.values()) {
			if (i == State.INITIAL) continue;
			System.out.format(" %s=%d", i, MoveCount[i.ordinal()]);
		}
		System.out.println();
	}
	
	private boolean debug;
	private State currentState;
	private TicTacToePosition currentPosition;	// current GamePosition
	private Move[] killers;						// killer moves from sibling positions
	private int empty;							// remaining empty squares
	private int mysq;							// squares occupied by side on move
	private int opsq;							// squares occupied by side off move
	
	/**
	 * Initialize move generator
	 * 
	 * Only the moves generated by CENTER, CORNERS, and SIDES are
	 * necessary.  The other states attempt to searching likely
	 * better moves first, which narrows the search by increasing
	 * the chances of alpha/beta cutoffs.
	 * 
	 * @param p	starting/current GamePosition
	 */
	public TicTacToeMoveGenerator(TicTacToePosition p, Move[] killers, boolean debug) {
		this.debug = debug;
		currentState = State.INITIAL;
		currentPosition = p;
		this.killers = killers;
		empty = p.empty();
		mysq = p.occupiedOnMove();
		opsq = p.occupiedOffMove();
	}
	
	public TicTacToeMoveGenerator(TicTacToePosition p) {
		this(p, new Move[0], false);
	}
	
	/**
	 * @return	true if moves remaining
	 */
	public boolean hasNext() {
		return empty != 0;
	}
	
	/* (non-Javadoc)
	 * @see kgorlen.games.MoveGenerator#next()
	 * 
	 * This should be implemented with a coroutine instead of
	 * switch (currentState); e.g. see:
	 * 
	 * 	https://code.google.com/p/coroutines
	 * 	https://github.com/offbynull/coroutines
	 * 	http://www.matthiasmann.de/content/view/24/26/
	 * 
	 */
	public Move next() {	// Return next move
		if (empty == 0) throw new NoSuchElementException();
		
		short nextMove;
		int m = 0;
		switch (currentState) {
			case INITIAL:
			case KILLER:			// beta cutoff moves from sibling position searches
				currentState = State.KILLER;
				for (int i=0; i<killers.length; i++) {
					if (killers[i] == null) break;
					m = empty & ((TicTacToeMove) killers[i]).toShort();
					if (m != 0) break;
				}
				if (m != 0) {
					if (debug) {
						System.out.format("%s killer move=%03x, position:%n",
								currentPosition.sideToMove(), m);
						currentPosition.print();
					}
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case THREATEN_159:						// Threaten or win 1-5-9 diagonal
				currentState = State.THREATEN_159;
				m = empty & 0x421;
				if (m != 0							// at least one empty square
					&& (mysq & 0x421) != 0			// at least one occupied by me
					&& (opsq & 0x421) == 0) {		// not blocked by opponent
					MoveCount[currentState.ordinal()]++;
					break;						
				}
			case THREATEN_357:						// Threaten or win 3-5-7 diagonal
				currentState = State.THREATEN_357;
				m = empty & 0x124;
				if (m != 0							// at least one empty square
					&& (mysq & 0x124) != 0			// at least one occupied by me
					&& (opsq & 0x124) == 0) {		// not blocked by opponent
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case THREATEN_ROW:						// Threaten or win three in a row
				currentState = State.THREATEN_ROW;
				m = empty;
				m = (m & 0x111) | (m & 0x222)>>1 | (m & 0x444>>2);				// at least one empty square
				m &= (mysq&0x111) | ((mysq&0x222)>>1) | ((mysq&0x444)>>2);		// at least one occupied by me
				m &= ~((opsq&0x111) | ((opsq&0x222)>>1) | ((opsq&0x444)>>2));	// not blocked by opponent
				if (m != 0) {
					m = (empty & m) | (empty & m<<1) | (empty & m<<2);
					if (debug) {
						System.out.format("%s threaten three-in-a-row move=%03x, position:%n",
								currentPosition.sideToMove(), m);
						currentPosition.print();
					}
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case THREATEN_COL:						// Threaten or win three in a column
				currentState = State.THREATEN_COL;
				m = empty;
				m = (m & 0x007) | ((m & 0x070)>>4) | ((m & 0x700)>>8);			// at least one empty square
				m &= (mysq&0x007) | ((mysq&0x070)>>4) | ((mysq&0x700)>>8);		// at least one occupied by me
				m &= ~((opsq&0x007) | ((opsq&0x070)>>4) | ((opsq&0x700)>>8));	// not blocked by opponent
				if (m != 0) {
					m = (empty & m) | (empty & m<<4) | (empty & m<<8);
					if (debug) {
						System.out.format("%s threaten three-in-a-column move=%03x, position:%n",
								currentPosition.sideToMove(), m);
						currentPosition.print();
					}
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case CORNERS:				// Corners
				currentState = State.CORNERS;
				m = empty & 0x505;
				if (m != 0) {
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case CENTER:				// Center
				currentState = State.CENTER;
				m = empty & 0x020;
				if (m != 0) {
					MoveCount[currentState.ordinal()]++;
					break;
				}
			case SIDES:					// Sides
				currentState = State.SIDES;
				m = empty & 0x252;
				if (m != 0) {
					MoveCount[currentState.ordinal()]++;
					break;
				}
			default:					// All moves generated
				return null;
		}
		nextMove = (short) (m & ~(m-1));	// select next move
		empty ^= nextMove;					// mark occupied
		return new TicTacToeMove(nextMove);
	}
}
