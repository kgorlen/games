package kgorlen.games.tictactoe;

import java.util.NoSuchElementException;

import kgorlen.games.Move;
import kgorlen.games.MoveGenerator;

/**
 * Generate legal Tic-Tac-Toe moves
 * 
 * @author Keith gorlen@comcast.net
 *
 */
public class TicTacToeMoveGenerator implements MoveGenerator {
	private static enum State {
		INITIAL, REFUTE, THREATEN_159, THREATEN_357,
		THREATEN_ROW,  THREATEN_COL, CENTER, CORNERS, SIDES
	};
	
	boolean debug;
	State currentState;
	TicTacToePosition currentPosition;	// current GamePosition
    int empty;							// remaining empty squares
    int mysq;							// squares occupied by side on move
    int opsq;							// squares occupied by side off move
	
	/**
	 * Initialize move generator
	 * 
	 * Only the moves generated by CENTER, CORNERS, and SIDES are
	 * necessary.  The other states attempt to searching likely
	 * better moves first, which narrows the search by increasing
	 * the chances of alpha/beta cutoffs.
	 * 
	 * Corners, Center, Sides:
	 * 	232427 positions searched, 32000 alpha cutoffs, 36552 beta cutoffs, 2.87 positions/us
	 * 
	 * Center, Corners, Sides:
	 * 	210911 positions searched, 24755 alpha cutoffs, 42894 beta cutoffs, 2.49 positions/us
	 * 
	 * Threats, Corners, Center, Sides:
	 * 	186533 positions searched, 25736 alpha cutoffs, 30552 beta cutoffs, 2.16 positions/us
	 * 
	 * Threats, Center, Corners, Sides:
	 * 	172258 positions searched, 20550 alpha cutoffs, 36548 beta cutoffs, 2.32 positions/us
	 * 
	 * @param p	starting/current GamePosition
	 */
	public TicTacToeMoveGenerator(TicTacToePosition p, boolean debug) {
		this.debug = debug;
		currentState = State.INITIAL;
		currentPosition = p;
		empty = p.empty();
		mysq = p.occupiedOnMove();
		opsq = p.occupiedOffMove();
	}
	
	public TicTacToeMoveGenerator(TicTacToePosition p) {
		this(p, false);
	}
	
	/**
	 * @return	true if moves remaining
	 */
	public boolean hasNext() {
		return empty != 0;
	}
	
	/* (non-Javadoc)
	 * @see kgorlen.games.MoveGenerator#next()
	 * 
	 * This should be implemented with a coroutine instead of
	 * switch (currentState); e.g. see:
	 * 
	 * 	https://code.google.com/p/coroutines
	 * 	https://github.com/offbynull/coroutines
	 * 	http://www.matthiasmann.de/content/view/24/26/
	 * 
	 */
	public Move next() {	// Return next move
		if (empty == 0) throw new NoSuchElementException();
		
		short nextMove;
		int m;
		switch (currentState) {
			case INITIAL:
			case REFUTE:		// Search move from principal variation
				currentState = State.REFUTE;
				// Not yet implemented
			case THREATEN_159:						// Threaten or win 1-5-9 diagonal
				currentState = State.THREATEN_159;
				m = empty & 0x421;
				if (m != 0							// at least one empty square
					&& (mysq & 0x421) != 0			// at least one occupied by me
					&& (opsq & 0x421) == 0) break;	// not blocked by opponent
			case THREATEN_357:						// Threaten or win 3-5-7 diagonal
				currentState = State.THREATEN_357;
				m = empty & 0x124;
				if (m != 0							// at least one empty square
					&& (mysq & 0x124) != 0			// at least one occupied by me
					&& (opsq & 0x124) == 0) break;	// not blocked by opponent
			case THREATEN_ROW:						// Threaten or win three in a row
				currentState = State.THREATEN_ROW;
				m = empty;
				m = (m & 0x111) | (m & 0x222)>>1 | (m & 0x444>>2);				// at least one empty square
				m &= (mysq&0x111) | ((mysq&0x222)>>1) | ((mysq&0x444)>>2);		// at least one occupied by me
				m &= ~((opsq&0x111) | ((opsq&0x222)>>1) | ((opsq&0x444)>>2));	// not blocked by opponent
				if (m != 0) {
					m = (empty & m) | (empty & m<<1) | (empty & m<<2);
					if (debug) {
						System.out.format("%s threaten three-in-a-row move=%03x, position:%n",
								currentPosition.sideToMove(), m);
						currentPosition.print();
					}
					break;
				}
			case THREATEN_COL:						// Threaten or win three in a column
				currentState = State.THREATEN_COL;
				m = empty;
				m = (m & 0x007) | ((m & 0x070)>>4) | ((m & 0x700)>>8);			// at least one empty square
				m &= (mysq&0x007) | ((mysq&0x070)>>4) | ((mysq&0x700)>>8);		// at least one occupied by me
				m &= ~((opsq&0x007) | ((opsq&0x070)>>4) | ((opsq&0x700)>>8));	// not blocked by opponent
				if (m != 0) {
					m = (empty & m) | (empty & m<<4) | (empty & m<<8);
					if (debug) {
						System.out.format("%s threaten three-in-a-column move=%03x, position:%n",
								currentPosition.sideToMove(), m);
						currentPosition.print();
					}
					break;
				}
			case CENTER:				// Center
				currentState = State.CENTER;
				m = empty & 0x020;
				if (m != 0) break;
			case CORNERS:				// Corners
				currentState = State.CORNERS;
				m = empty & 0x505;
				if (m != 0) break;
			case SIDES:					// Sides
				currentState = State.SIDES;
				m = empty & 0x252;
				if (m != 0) break;
			default:					// All moves generated
				return null;
		}
		nextMove = (short) (m & ~(m-1));	// select next move
		empty ^= nextMove;					// mark occupied
		return new TicTacToeMove(nextMove);
	}
}
